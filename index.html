<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="technical.css">
        <title>Technical Documentation Page</title>
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300;400;500;600;700&family=Ubuntu:wght@300;400;500;700&display=swap" rel="stylesheet">
        <script src="https://kit.fontawesome.com/861ecf43a0.js" crossorigin="anonymous"></script>
    </head>
    

    <header class="top-nav">
        <!--<h2>Git Documentation Page</h2>-->
    </header>
    
    <nav id="navbar">
        <header id="nav-caption"><span id="navlogo"><i class="fab fa-git-alt"></i></span>Git Basics</header>
        <ul id="nav-link-section">
            <li>
                <a class="nav-link" href="#About_Version_Control">About Version Control</a>
            </li>
            <li>
                <a class="nav-link" href="#What_is_Git">What is Git</a>
            </li>
            <li>
                <a class="nav-link" href="#Installing_Git">Installing Git</a>
            </li>
            <li>
                <a class="nav-link" href="#First-Time_Git_Setup">First-Time Git Setup</a>
            </li>
            <li>
                <a class="nav-link" href="#Getting_Help">Getting Help</a>
            </li>
            <li>
                <a class="nav-link" href="#Getting_a_Git_Repository">Getting a Git Repository</a>
            </li>
            <li>
                <a class="nav-link" href="#Checking_File_Status">Checking File Status</a>
            </li>
            <li>
                <a class="nav-link" href="#Tracking_New_Files">Tracking new files</a>
            </li>
            <li>
                <a class="nav-link" href="#Committing_Your_Changes">Committing Your Changes</a>
            </li>
            <li>
                <a class="nav-link" href="#Summary">Summary</a>
            </li>
            <li>
                <a class="nav-link" href="#Reference">Reference</a>
            </li>
        </ul>
    </nav>
    
    <main id="main-doc">
        <section class="main-section" id="About_Version_Control">
            <header><h2>About Version Control</h2></header>
            <article>
                <h3>Version control</h3>
                <p>
                    What is “version control”, and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. If you are a graphic or web designer and want to keep every version of an image or layout (which you would most certainly want to), a Version Control System (VCS) is a very wise thing to use. It allows you to revert selected files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead.
                </p>
            </article>
        </section>

        <section class="main-section" id="What_is_Git">
            <header><h2>What is Git</h2></header>
            <article>
                <h3>The Three States</h3>
                <p>
                    Git has three main states that your files can reside in: <samp>modified, staged</samp>, and <samp>committed</samp>:
                </p>                
                <ul>
                    <li>Modified means that you have changed the file but have not committed it to your database yet.</li>
                    <li>Staged means that you have marked a modified file in its current version to go into your next commit snapshot.</li>
                    <li>Committed means that the data is safely stored in your local database.</li>
                </ul>
                
            </article>
        </section>

        <section class="main-section" id="Installing_Git"> 
            <header><h2>Installing Git</h2></header>
            <article>
                <p>
                    Before you start using Git, you have to make it available on your computer. Even if it’s already installed, it’s probably a good idea to update to the latest version. You can either install it as a package or via another installer, or download the source code and compile it yourself.
                </p>
                <h3>Installing on Linux</h3>
                <p>
                    If you want to install the basic Git tools on Linux via a binary installer, you can generally do so through the package management tool that comes with your distribution. If you’re on Fedora (or any closely-related RPM-based distribution, such as RHEL or CentOS), you can use <mark>dnf</mark>:
                </p>
                <code>$ sudo dnf install git-all</code>
                <p>
                    If you’re on a Debian-based distribution, such as Ubuntu, try <mark>apt</mark>:
                </p>
                <code>$ sudo apt install git-all</code>
                <p>
                    For more options, there are instructions for installing on several different Unix distributions on the Git website, at <a href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a>.
                </p>
            </article>
        </section>

        <section class="main-section" id="First-Time_Git_Setup">
            <header><h2>First-Time Git Setup</h2></header>
            <article class="bottom-space">
                <p>
                    Now that you have Git on your system, you’ll want to do a few things to customize your Git environment. You should have to do these things only once on any given computer; they’ll stick around between upgrades. You can also change them at any time by running through the commands again.
                </p>
                <p>
                    Git comes with a tool called <mark>git config</mark> that lets you get and set configuration variables that control all aspects of how Git looks and operates. These variables can be stored in three different places:
                </p>
                <ol>
                    <li>
                        <mark>[path]/etc/gitconfig</mark> file: Contains values applied to every user on the system and all their repositories. If you pass the option <mark>--system</mark> to <mark>git config</mark>, it reads and writes from this file specifically. Because this is a system configuration file, you would need administrative or superuser privilege to make changes to it.
                    </li>
                    <li>
                        <mark>~/.gitconfig</mark> or <mark>~/.config/git/config file</mark>: Values specific personally to you, the user. You can make Git read and write to this file specifically by passing the <mark>--global</mark> option, and this affects all of the repositories you work with on your system.
                    </li>
                    <li>
                        <mark>config</mark> file in the Git directory (that is, <mark>.git/config</mark>) of whatever repository you’re currently using: Specific to that single repository. You can force Git to read from and write to this file with the <mark>--local</mark> option, but that is in fact the default. Unsurprisingly, you need to be located somewhere in a Git repository for this option to work properly.
                    </li>
                </ol>
                
                <h3>Your Identity</h3>
                <p>
                    The first thing you should do when you install Git is to set your user name and email address. This is important because every Git commit uses this information, and it’s immutably baked into the commits you start creating:
                </p>
                <code>$ git config --global user.name "John Doe"
                    $ git config --global user.email johndoe@example.com</code>
                <p>
                    Again, you need to do this only once if you pass the <mark>--global</mark> option, because then Git will always use that information for anything you do on that system. If you want to override this with a different name or email address for specific projects, you can run the command without the <mark>--global</mark> option when you’re in that project.
                </p>
                <p>Many of the GUI tools will help you do this when you first run them.</p>
                
                <h3>Your default branch name</h3>
                <p>
                    By default Git will create a branch called <samp>master</samp> when you create a new repository with <mark>git init</mark>. From Git version 2.28 onwards, you can set a different name for the initial branch.
                </p>
                <p>To set <samp>main</samp> as the default branch name do:</p>
                <code>$ git config --global init.defaultBranch main</code>
                
                <h3>Checking Your Settings</h3>
                <p>
                    If you want to check your configuration settings, you can use the <mark>git config --list</mark> command to list all the settings Git can find at that point:
                </p>
                <code>$ git config --list
                    user.name=John Doe
                    user.email=johndoe@example.com
                    color.status=auto
                    color.branch=auto
                    color.interactive=auto
                    color.diff=auto
                    ...</code>
                                
            </article>
        </section>

        <section class="main-section" id="Getting_Help">
            <header><h2>Getting Help</h2></header>
            <article class="bottom-space">
                <h3>Git help</h3>
                <p>If you ever need help while using Git, there are three equivalent ways to get the comprehensive manual page (manpage) help for any of the Git commands:</p>
                <code>$ git help &lt;verb&gt;
                    $ git &lt;verb&gt; --help
                    $ man git-&lt;verb&gt;</code>

                <p>For example, you can get the manpage help for the <mark>git config</mark> command by running this:</p>
                <code>$ git help config</code>
                <p>
                    These commands are nice because you can access them anywhere, even offline. If the manpages and this book aren’t enough and you need in-person help, you can try the <mark>#git</mark> or <mark>#github</mark> channel on the Freenode IRC server, which can be found at <a href="https://freenode.net">https://freenode.net</a>. These channels are regularly filled with hundreds of people who are all very knowledgeable about Git and are often willing to help.
                </p>
                <p>
                    In addition, if you don’t need the full-blown manpage help, but just need a quick refresher on the available options for a Git command, you can ask for the more concise “help” output with the <mark>-h</mark> option, as in:
                </p>
                
                <code>$ git add -h
                    usage: git add [&lt;options&gt;] [--] &lt;pathspec&gt;...
                    
                        -n, --dry-run         dry run
                        -v, --verbose         be verbose
                    
                        -i, --interactive     interactive picking
                        -p, --patch           select hunks interactively
                        -e, --edit            edit current diff and apply
                        -f, --force           allow adding otherwise ignored files
                        -u, --update          update tracked files
                        --renormalize         renormalize EOL of tracked files (implies -u)
                        -N, --intent-to-add   record only the fact that the path will be added later
                        -A, --all             add changes from all tracked and untracked files
                        --ignore-removal      ignore paths removed in the working tree (same as --no-all)
                        --refresh             don't add, only refresh the index
                        --ignore-errors       just skip files which cannot be added because of errors
                        --ignore-missing      check if - even missing - files are ignored in dry run
                        --chmod (+|-)x        override the executable bit of the listed files
                    </code>
                                
            </article>
        </section>

        <section class="main-section" id="Getting_a_Git_Repository">
            <header><h2>Getting a Git Repository</h2></header>
            <article>
                <p>You typically obtain a Git repository in one of two ways:</p>
                <ol>
                    <li>You can take a local directory that is currently not under version control, and turn it into a Git repository, or</li>
                    <li>You can <samp>clone</samp> an existing Git repository from elsewhere.</li>
                </ol>
                <p>In either case, you end up with a Git repository on your local machine, ready for work.</p>

                <h3>Initializing a Repository in an Existing Directory</h3>
                <p>
                    If you have a project directory that is currently not under version control and you want to start controlling it with Git, you first need to go to that project’s directory. If you’ve never done this, it looks a little different depending on which system you’re running:
                </p>
                <p>for Linux:</p>
                <code>$ cd /home/user/my_project</code>
                <p>for macOS:</p>
                <code>$ cd /Users/user/my_project</code>
                <p>for Windows:</p>
                <code>$ cd C:/Users/user/my_project</code>

                <p>
                    This creates a new subdirectory named <mark>.git</mark> that contains all of your necessary repository files — a Git repository skeleton. At this point, nothing in your project is tracked yet. If you want to start version-controlling existing files (as opposed to an empty directory), you should probably begin tracking those files and do an initial commit. You can accomplish that with a few <mark>git add</mark> commands that specify the files you want to track, followed by a <mark>git commit</mark>:
                </p>

                <code>$ git add *.c
                    $ git add LICENSE
                    $ git commit -m 'Initial project version'</code>

                <h3>Cloning an Existing Repository</h3>
                <p>
                    If you want to get a copy of an existing Git repository — for example, a project you’d like to contribute to — the command you need is <mark>git clone</mark>. If you’re familiar with other VCSs such as Subversion, you’ll notice that the command is "clone" and not "checkout". This is an important distinction — instead of getting just a working copy, Git receives a full copy of nearly all data that the server has. Every version of every file for the history of the project is pulled down by default when you run <mark>git clone</mark> In fact, if your server disk gets corrupted, you can often use nearly any of the clones on any client to set the server back to the state it was in when it was cloned.
                </p>
                <P>
                    You clone a repository with <mark>git clone &lt;url&gt;</mark>. For example, if you want to clone the Git linkable library called <mark>libgit2</mark>, you can do so like this:
                </P>
                <code>$ git clone https://github.com/libgit2/libgit2</code>

                <p>
                    That creates a directory named <mark>libgit2</mark>, initializes a <mark>.git</mark> directory inside it, pulls down all the data for that repository, and checks out a working copy of the latest version. If you go into the new <mark>libgit2</mark> directory that was just created, you’ll see the project files in there, ready to be worked on or used.
                </p>
                <p>
                    If you want to clone the repository into a directory named something other than <mark>libgit2</mark>, you can specify the new directory name as an additional argument:
                </p>
                <code>$ git clone https://github.com/libgit2/libgit2 mylibgit</code>

                <p>That command does the same thing as the previous one, but the target directory is called <mark>mylibgit</mark>.</p>
            </article>
        </section>

        <section class="main-section" id="Checking_File_Status">
            <header><h2>Checking File status</h2></header>
            <article>
                <h3>Git Status</h3>
                <p>The main tool you use to determine which files are in which state is the <mark>git status</mark> command. If you run this command directly after a clone, you should see something like this:</p>
                <code>$ git status
                    On branch master
                    Your branch is up-to-date with 'origin/master'.
                    nothing to commit, working tree clean</code>

                <p>
                    This means you have a clean working directory; in other words, none of your tracked files are modified. Git also doesn’t see any untracked files, or they would be listed here. Finally, the command tells you which branch you’re on and informs you that it has not diverged from the same branch on the server. For now, that branch is always <mark>master</mark>, which is the default; you won’t worry about it here.
                </p>
            </article>
        </section>

        <section class="main-section" id="Tracking_New_Files">
            <header><h2>Tracking New Files</h2></header>
            <article>
                <h3>Git add</h3>
                <p>
                    In order to begin tracking a new file, you use the command <mark>git add</mark>. To begin tracking the README file, you can run this:
                </p>
                <code>$ git add README</code>

                <p>
                    If you run your status command again, you can see that your <mark>README</mark> file is now tracked and staged to be committed:
                </p>
                <code>$ git status
                    On branch master
                    Your branch is up-to-date with 'origin/master'.
                    Changes to be committed:
                      (use "git restore --staged &lt;file&gt;..." to unstage)
                    
                        new file:   README</code>

                <p>
                    You can tell that it’s staged because it’s under the “Changes to be committed” heading. If you commit at this point, the version of the file at the time you ran <mark>git add</mark> is what will be in the subsequent historical snapshot. You may recall that when you ran <mark>git init</mark> earlier, you then ran <mark>git add &lt;files&gt;</mark> — that was to begin tracking files in your directory. The <mark>git add</mark> command takes a path name for either a file or a directory; if it’s a directory, the command adds all the files in that directory recursively.
                </p>
            </article>
        </section>

        <section class="main-section" id="Committing_Your_Changes">
            <header><h2>Committing Your Changes</h2></header>
            <article>
                <h3>Git commit</h3>
                <p>
                    Now that your staging area is set up the way you want it, you can commit your changes. Remember that anything that is still unstaged — any files you have created or modified that you haven’t run <mark>git add</mark> on since you edited them — won’t go into this commit. They will stay as modified files on your disk. In this case, let’s say that the last time you ran <mark>git status</mark>, you saw that everything was staged, so you’re ready to commit your changes. The simplest way to commit is to type <mark>git commit</mark>:
                </p>
                <code>$ git commit</code>

                <p>Doing so launches your editor of choice. The editor displays the following text (this example is a Vim screen):</p>
                <code># Please enter the commit message for your changes. Lines starting
                    # with '#' will be ignored, and an empty message aborts the commit.
                    # On branch master
                    # Your branch is up-to-date with 'origin/master'.
                    #
                    # Changes to be committed:
                    #	new file:   README
                    #	modified:   CONTRIBUTING.md
                    #
                    ~
                    ~
                    ~
                    ".git/COMMIT_EDITMSG" 9L, 283C</code>
                
                <p>
                    You can see that the default commit message contains the latest output of the <mark>git status</mark> command commented out and one empty line on top. You can remove these comments and type your commit message, or you can leave them there to help you remember what you’re committing. When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out).
                </p>
                <p>
                    Alternatively, you can type your commit message inline with the <mark>commit</mark> command by specifying it after a <mark>-m</mark> flag, like this:
                </p>
                <code>$ git commit -m "Story 182: fix benchmarks for speed"
                    [master 463dc4f] Story 182: fix benchmarks for speed
                     2 files changed, 2 insertions(+)
                     create mode 100644 README</code>

                <p>
                    Now you’ve created your first commit! You can see that the commit has given you some output about itself: which branch you committed to ( <mark>master</mark> ), what SHA-1 checksum the commit has ( <mark>463dc4f</mark> ), how many files were changed, and statistics about lines added and removed in the commit. 
                </p>
                <p>
                    Remember that the commit records the snapshot you set up in your staging area. Anything you didn’t stage is still sitting there modified; you can do another commit to add it to your history. Every time you perform a commit, you’re recording a snapshot of your project that you can revert to or compare to later.
                </p>
            </article>
        </section>

        <section class="main-section" id="Summary">
            <header><h2>Summary</h2></header>
            <article>
                <h3>In a nutshell</h3>
                <p>
                    At this point, you should have a basic understanding of what Git is and how it’s different from any centralized version control systems you may have been using previously. You should now have a working version of Git on your system that’s set up with your personal identity. You should also be able to do most basic local Git operations — creating or cloning a repository, making changes, staging and committing those changes, and viewing the history of all the changes the repository has been through.
                </p>
            </article>
        </section>

        <section class="main-section" id="Reference">
            <header><h2>Reference</h2></header>
            <article>
                <h3>Pro Git</h3>
                <p>All the documentation in this page is taken from the <a href="https://git-scm.com/book/en/v2">Pro Git book</a> (2nd Edition, 2014), written by Scott Chacon and Ben Straub.</p>
            </article>
        </section>

    </main>
   
    <footer id="footer">
        <div class="footer-content">
            <div class="footer-content-left"> 
                <span>Copyright &copy; 2021</span>
            </div>    
            <div class="footer-content-right">
                <span>Designed by dewslyse</span>
            </div> 
        </div>              
    </footer>

        
</html>